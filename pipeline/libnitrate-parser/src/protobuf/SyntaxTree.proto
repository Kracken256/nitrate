// Contents: Nitrate parser syntax tree protobuf definition.
// Author: Wesley Jones

syntax = "proto2";

package nitrate.parser.SyntaxTree;

/* Represents a source location in a translation unit. */
message SourceLocation {
  required uint32 line = 1;
  required uint32 column = 2;
  required uint32 offset = 3;
  required string file = 4;
}

/* Represents a contiguous span of a translation unit. */
message SourceLocationRange {
  optional SourceLocation start = 1;
  optional SourceLocation end = 2;
}

/* Represents a source code comment. */
message UserComment {
  required string comment = 1;
}

/* Represents the polymorphic base of all syntax tree nodes. */
message Base {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;
}

///===--------------------------------------------------------------------===///

/* Represents an unresolved named type. */
message NamedTy {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;

  required string name = 7;
}

/* Represents a placeholder type subject to type inference. */
message InferTy {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

/* Represents a template type instantiation. */
message TemplateType {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;

  required Type template_base = 7;
  repeated Type arguments = 8;
}

/* Represents a 1-bit unsigned integer primitive type. */
message U1 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

/* Represents an 8-bit unsigned integer primitive type. */
message U8 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

/* Represents a 16-bit unsigned integer primitive type. */
message U16 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

/* Represents a 32-bit unsigned integer primitive type. */
message U32 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

/* Represents a 64-bit unsigned integer primitive type. */
message U64 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

/* Represents a 128-bit unsigned integer primitive type. */
message U128 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

/* Represents an 8-bit signed integer primitive type. */
message I8 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

/* Represents a 16-bit signed integer primitive type. */
message I16 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

/* Represents a 32-bit signed integer primitive type. */
message I32 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

/* Represents a 64-bit signed integer primitive type. */
message I64 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

/* Represents a 128-bit signed integer primitive type. */
message I128 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

/* Represents a 16-bit floating point primitive type. */
message F16 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

/* Represents a 32-bit floating point primitive type. */
message F32 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

/* Represents a 64-bit floating point primitive type. */
message F64 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

/* Represents a 128-bit floating point primitive type. */
message F128 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

/* Represents an empty 'void' type of size 0. */
message VoidTy {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

/* Represents a raw pointer type. */
message PtrTy {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;

  /* The type of the thing being pointed to. */
  required Type pointee = 7;
}

/* Represents a type defined by name only. */
message OpaqueTy {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;

  required string identity_name = 7;
}

/* Represents an anonymous aggregate type. */
message TupleTy {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;

  /* The types of the elements in the tuple. */
  repeated Type elements = 7;
}

/* Represents a fixed-size array type. */
message ArrayTy {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;

  required Type element_type = 7;
  required Expr element_count = 8;
}

/* Represents a reference type. */
message RefTy {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;

  required Type pointee_type = 7;
}

enum FunctionPurity {
  Impure = 0;
  Impure_TSafe = 1;
  Pure = 2;
  Quasi = 3;
  Retro = 4;
}

message FunctionParameter {
  required string name = 1;
  required Type type = 2;
  optional Expr default_value = 3;
}

message FuncTy {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;

  repeated Expr attributes = 7;
  repeated FunctionParameter parameters = 8;
  required Type return_type = 9;
  required FunctionPurity purity = 10;
  required bool is_variadic = 11;
}

///===--------------------------------------------------------------------===///

enum Operator {
  Plus = 0;         /* '+':    Addition operator */
  Minus = 1;        /* '-':    Subtraction operator */
  Times = 2;        /* '*':    Multiplication operator */
  Slash = 3;        /* '/':    Division operator */
  Percent = 4;      /* '%':    Modulus operator */
  BitAnd = 5;       /* '&':    Bitwise AND operator */
  BitOr = 6;        /* '|':    Bitwise OR operator */
  BitXor = 7;       /* '^':    Bitwise XOR operator */
  BitNot = 8;       /* '~':    Bitwise NOT operator */
  LShift = 9;       /* '<<':   Left shift operator */
  RShift = 10;      /* '>>':   Right shift operator */
  ROTL = 11;        /* '<<<':  Rotate left operator */
  ROTR = 12;        /* '>>>':  Rotate right operator */
  LogicAnd = 13;    /* '&&':   Logical AND operator */
  LogicOr = 14;     /* '||':   Logical OR operator */
  LogicXor = 15;    /* '^^':   Logical XOR operator */
  LogicNot = 16;    /* '!':    Logical NOT operator */
  LT = 17;          /* '<':    Less than operator */
  GT = 18;          /* '>':    Greater than operator */
  LE = 19;          /* '<=':   Less than or equal to operator */
  GE = 20;          /* '>=':   Greater than or equal to operator */
  Eq = 21;          /* '==':   Equal to operator */
  NE = 22;          /* '!=':   Not equal to operator */
  Set = 23;         /* '=':    Assignment operator */
  PlusSet = 24;     /* '+=':   Addition assignment operator */
  MinusSet = 25;    /* '-=':   Subtraction assignment operator */
  TimesSet = 26;    /* '*=':   Multiplication assignment operator */
  SlashSet = 27;    /* '/=':   Division assignment operator */
  PercentSet = 28;  /* '%=':   Modulus assignment operator */
  BitAndSet = 29;   /* '&=':   Bitwise AND assignment operator */
  BitOrSet = 30;    /* '|=':   Bitwise OR assignment operator */
  BitXorSet = 31;   /* '^=':   Bitwise XOR assignment operator */
  LogicAndSet = 32; /* '&&=':  Logical AND assignment operator */
  LogicOrSet = 33;  /* '||=':  Logical OR assignment operator */
  LogicXorSet = 34; /* '^^=':  Logical XOR assignment operator */
  LShiftSet = 35;   /* '<<=':  Left shift assignment operator */
  RShiftSet = 36;   /* '>>=':  Right shift assignment operator */
  ROTLSet = 37;     /* '<<<=': Rotate left assignment operator */
  ROTRSet = 38;     /* '>>>=': Rotate right assignment operator */
  Inc = 39;         /* '++':   Increment operator */
  Dec = 40;         /* '--':   Decrement operator */
  As = 41;          /* 'as':   Type cast operator */
  BitcastAs = 42;   /* 'bitcast_as': Bitcast operator */
  In = 43;          /* 'in':         Generic membership operator */
  Out = 44;         /* 'out':        Output operator */
  Sizeof = 45;      /* 'sizeof':     Size of operator */
  Bitsizeof = 46;   /* 'bitsizeof':  Bit size of operator */
  Alignof = 47;     /* 'alignof':    Alignment of operator */
  Typeof = 48;      /* 'typeof':     Type of operator */
  Comptime = 49;    /* 'comptime':   Compile-time operator */
  Dot = 50;         /* '.':          Dot operator */
  Range = 51;       /* '..':         Range operator */
  Ellipsis = 52;    /* '...':        Ellipsis operator */
  Arrow = 53;       /* '=>':         Arrow operator */
  Ternary = 54;     /* '?':          Ternary operator */
};

/* An adapter from expression to statement. */
message ExprStmt {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr expr = 4;
}

/* An adapter from statement to expression. */
message StmtExpr {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Stmt stmt = 4;
}

/* An adapter from type to expression. */
message TypeExpr {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Type type = 4;
}

message UnaryExpression {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Operator op = 4;
  required Expr operand = 5;
}

message BinaryExpression {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Operator op = 4;
  required Expr lhs = 5;
  required Expr rhs = 6;
}

message PostUnaryExpression {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Operator op = 4;
  required Expr operand = 5;
}

message TernaryExpression {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr condition = 4;
  required Expr true_branch = 5;
  required Expr false_branch = 6;
}

message Integer {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /* Don't forget to verify me! */
  /* I'm a plain integer in range [0, 2^128). */
  required string value = 4;
}

message Float {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /* Don't forget to verify me! */
  /* I'm in plain decimal form. */
  required string value = 4;
}

message Boolean {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required bool value = 4;
}

message String {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /* I might contain any binary data. */
  required bytes value = 4;
}

message Character {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /* Range: [0, 2^8). */
  required uint32 value = 4;
}

message Null {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;
}

message Undefined {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;
}

message Call {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message TemplateCall {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message List {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  repeated Expr elements = 4;
}

message Assoc {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr key = 4;
  required Expr value = 5;
}

message Index {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr base = 4;
  required Expr index = 5;
}

message Slice {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr base = 4;
  required Expr start = 5;
  required Expr end = 6;
}

message FString {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message Identifier {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required string name = 4;
}

message Sequence {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  repeated Expr terms = 4;
}

///===--------------------------------------------------------------------===///

message Block {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message Variable {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message Assembly {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message If {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message While {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message For {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message Foreach {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message Break {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message Continue {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message Return {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message ReturnIf {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message Case {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message Switch {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message Typedef {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message Function {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message Struct {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message Enum {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message Scope {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message Export {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /// TODO:
}

message Expr {
  oneof node {
    Base base = 1;
    StmtExpr stmt = 2;
    TypeExpr type = 3;
    UnaryExpression unary_expression = 4;
    BinaryExpression binary_expression = 5;
    PostUnaryExpression post_unary_expression = 6;
    TernaryExpression ternary_expression = 7;
    Integer integer = 8;
    Float float = 9;
    Boolean boolean = 10;
    String string = 11;
    Character character = 12;
    Null null = 13;
    Undefined undefined = 14;
    Call call = 15;
    TemplateCall template_call = 16;
    List list = 17;
    Assoc assoc = 18;
    Index index = 19;
    Slice slice = 20;
    FString fstring = 21;
    Identifier identifier = 22;
    Sequence sequence = 23;
  }
}

message Stmt {
  oneof node {
    Base base = 1;
    ExprStmt expr = 2;
    Block block = 3;
    Variable variable = 4;
    Assembly assembly = 5;
    If if = 6;
    While while = 7;
    For for = 8;
    Foreach foreach = 9;
    Break break = 10;
  }
}

message Type {
  oneof node {
    Base base = 1;
    NamedTy named = 2;
    InferTy infer = 3;
    TemplateType template = 4;
    U1 u1 = 5;
    U8 u8 = 6;
    U16 u16 = 7;
    U32 u32 = 8;
    U64 u64 = 9;
    U128 u128 = 10;
    I8 i8 = 11;
    I16 i16 = 12;
    I32 i32 = 13;
    I64 i64 = 14;
    I128 i128 = 15;
    F16 f16 = 16;
    F32 f32 = 17;
    F64 f64 = 18;
    F128 f128 = 19;
    VoidTy void = 20;
    PtrTy ptr = 21;
    OpaqueTy opaque = 22;
    TupleTy tuple = 23;
    ArrayTy array = 24;
    RefTy ref = 25;
    FuncTy func = 26;
  }
}