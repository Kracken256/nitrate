// Contents: Nitrate language syntax tree protobuf definition.
// Author: Wesley Jones

syntax = "proto2";

package nitrate.parser.SyntaxTree;

message SourceLocation {
  required uint32 line = 1;
  required uint32 column = 2;
  required uint32 offset = 3;
  optional string file = 4;
}

message SourceLocationRange {
  optional SourceLocation start = 1;
  optional SourceLocation end = 2;
}

message UserComment {
  required string comment = 1;
}

message Base {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;
}

message CallArgument {
  required string name = 1;
  required Expr value = 2;
}

enum FunctionPurity {
  Impure = 0;
  Impure_TSafe = 1;
  Pure = 2;
  Quasi = 3;
  Retro = 4;
}

message FunctionParameter {
  required string name = 1;
  required Type type = 2;
  optional Expr default_value = 3;
}

message FStringTerm {
  oneof part {
    string text = 1;
    Expr expr = 2;
  }
}

enum SafetyMode {
  Safe = 0;
  Unsafe = 1;
}

enum VariableKind {
  Const = 0;
  Var = 1;
  Let = 2;
}

enum Vis {
  Public = 0;
  Private = 1;
  Protected = 2;
}

message TemplateParameter {
  required string name = 1;
  required Type type = 2;
  optional Expr default_value = 3;
}

message TemplateParameters {
  repeated TemplateParameter parameters = 1;
}

message FunctionCapture {
  required string name = 1;
  required bool is_reference = 2;
}

message StructField {
  required string name = 1;
  optional Expr default_value = 3;
  required Type type = 2;
  required Vis visibility = 4;
  required bool is_static = 5;
}

message StructMethod {
  required Stmt func = 1;
  required Vis visibility = 2;
}

enum AggregateKind {
  Region_ = 0;
  Struct_ = 1;
  Group_ = 2;
  Class_ = 3;
  Union_ = 4;
}

message EnumItem {
  required string name = 1;
  optional Expr value = 2;
}

///===--------------------------------------------------------------------===///

message NamedTy {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;

  required string type_name = 7;
}

message InferTy {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

message TemplateType {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;

  required Type template_base = 7;
  repeated CallArgument template_arguments = 8;
}

message U1 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

message U8 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

message U16 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

message U32 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

message U64 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

message U128 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

message I8 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

message I16 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

message I32 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

message I64 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

message I128 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

message F16 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

message F32 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

message F64 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

message F128 {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

message VoidTy {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;
}

message PtrTy {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;

  required Type pointee = 7;
  required bool is_volatile = 8;
}

message OpaqueTy {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;

  required string identity_name = 7;
}

message TupleTy {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;

  repeated Type member_types = 7;
}

message ArrayTy {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;

  required Type element_type = 7;
  required Expr element_count = 8;
}

message RefTy {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;

  required Type pointee_type = 7;
}

message FuncTy {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr bit_width = 4;
  optional Expr minimum_value = 5;
  optional Expr maximum_value = 6;

  repeated Expr attributes = 7;
  repeated FunctionParameter parameters = 8;
  required Type return_type = 9;
  required FunctionPurity purity = 10;
  required bool is_variadic = 11;
}

///===--------------------------------------------------------------------===///

enum Operator {
  Plus = 0;         /* '+':    Addition operator */
  Minus = 1;        /* '-':    Subtraction operator */
  Times = 2;        /* '*':    Multiplication operator */
  Slash = 3;        /* '/':    Division operator */
  Percent = 4;      /* '%':    Modulus operator */
  BitAnd = 5;       /* '&':    Bitwise AND operator */
  BitOr = 6;        /* '|':    Bitwise OR operator */
  BitXor = 7;       /* '^':    Bitwise XOR operator */
  BitNot = 8;       /* '~':    Bitwise NOT operator */
  LShift = 9;       /* '<<':   Left shift operator */
  RShift = 10;      /* '>>':   Right shift operator */
  ROTL = 11;        /* '<<<':  Rotate left operator */
  ROTR = 12;        /* '>>>':  Rotate right operator */
  LogicAnd = 13;    /* '&&':   Logical AND operator */
  LogicOr = 14;     /* '||':   Logical OR operator */
  LogicXor = 15;    /* '^^':   Logical XOR operator */
  LogicNot = 16;    /* '!':    Logical NOT operator */
  LT = 17;          /* '<':    Less than operator */
  GT = 18;          /* '>':    Greater than operator */
  LE = 19;          /* '<=':   Less than or equal to operator */
  GE = 20;          /* '>=':   Greater than or equal to operator */
  Eq = 21;          /* '==':   Equal to operator */
  NE = 22;          /* '!=':   Not equal to operator */
  Set = 23;         /* '=':    Assignment operator */
  PlusSet = 24;     /* '+=':   Addition assignment operator */
  MinusSet = 25;    /* '-=':   Subtraction assignment operator */
  TimesSet = 26;    /* '*=':   Multiplication assignment operator */
  SlashSet = 27;    /* '/=':   Division assignment operator */
  PercentSet = 28;  /* '%=':   Modulus assignment operator */
  BitAndSet = 29;   /* '&=':   Bitwise AND assignment operator */
  BitOrSet = 30;    /* '|=':   Bitwise OR assignment operator */
  BitXorSet = 31;   /* '^=':   Bitwise XOR assignment operator */
  LogicAndSet = 32; /* '&&=':  Logical AND assignment operator */
  LogicOrSet = 33;  /* '||=':  Logical OR assignment operator */
  LogicXorSet = 34; /* '^^=':  Logical XOR assignment operator */
  LShiftSet = 35;   /* '<<=':  Left shift assignment operator */
  RShiftSet = 36;   /* '>>=':  Right shift assignment operator */
  ROTLSet = 37;     /* '<<<=': Rotate left assignment operator */
  ROTRSet = 38;     /* '>>>=': Rotate right assignment operator */
  Inc = 39;         /* '++':   Increment operator */
  Dec = 40;         /* '--':   Decrement operator */
  As = 41;          /* 'as':   Type cast operator */
  BitcastAs = 42;   /* 'bitcast_as': Bitcast operator */
  In = 43;          /* 'in':         Generic membership operator */
  Out = 44;         /* 'out':        Output operator */
  Sizeof = 45;      /* 'sizeof':     Size of operator */
  Bitsizeof = 46;   /* 'bitsizeof':  Bit size of operator */
  Alignof = 47;     /* 'alignof':    Alignment of operator */
  Typeof = 48;      /* 'typeof':     Type of operator */
  Comptime = 49;    /* 'comptime':   Compile-time operator */
  Dot = 50;         /* '.':          Dot operator */
  Range = 51;       /* '..':         Range operator */
  Ellipsis = 52;    /* '...':        Ellipsis operator */
  Arrow = 53;       /* '=>':         Arrow operator */
  Ternary = 54;     /* '?':          Ternary operator */
};

message StmtExpr {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Stmt stmt = 4;
}

message TypeExpr {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Type type = 4;
}

message UnaryExpression {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr rhs = 4;
  required Operator op = 5;
}

message BinaryExpression {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr lhs = 4;
  required Expr rhs = 5;
  required Operator op = 6;
}

message PostUnaryExpression {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr lhs = 4;
  required Operator op = 5;
}

message TernaryExpression {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr condition = 4;
  required Expr lhs = 5;
  required Expr rhs = 6;
}

message Integer {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /* Don't forget to verify me! */
  /* I'm a plain integer in range [0, 2^128). */
  required string value = 4;
}

message Float {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /* Don't forget to verify me! */
  /* I'm in plain decimal form. */
  required string value = 4;
}

message Boolean {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required bool value = 4;
}

message String {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required bytes value = 4;
}

message Character {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  /* Range: [0, 2^8). */
  required uint32 value = 4;
}

message Null {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;
}

message Undefined {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;
}

message Call {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr callee = 4;
  repeated CallArgument arguments = 5;
}

message TemplateCall {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr callee = 4;
  repeated CallArgument template_arguments = 6;
  repeated CallArgument arguments = 5;
}

message List {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  repeated Expr elements = 4;
}

message Assoc {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr key = 4;
  required Expr value = 5;
}

message Index {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr base = 4;
  required Expr index = 5;
}

message Slice {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr base = 4;
  required Expr start = 5;
  required Expr end = 6;
}

message FString {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  repeated FStringTerm terms = 4;
}

message Identifier {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required string name = 4;
}

message Sequence {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  repeated Expr terms = 4;
}

///===--------------------------------------------------------------------===///

message ExprStmt {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr expr = 4;
}

message Block {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  repeated Stmt statements = 5;
  optional SafetyMode safety = 4;
}

message Variable {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  repeated Expr attributes = 4;
  optional Type type = 5;
  optional Expr value = 6;
  required VariableKind decl_kind = 7;
  required string name = 8;
}

message Assembly {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  repeated Expr arguments = 4;
  required string code = 5;
}

message If {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr condition = 4;
  required Stmt then = 5;
  optional Stmt else = 6;
}

message While {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr condition = 4;
  required Stmt body = 5;
}

message For {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Stmt init = 4;
  optional Expr condition = 5;
  optional Expr step = 6;
  required Stmt body = 7;
}

message Foreach {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr expr = 4;
  required Stmt body = 5;
  required string index_name = 6;
  required string value_name = 7;
}

message Break {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;
}

message Continue {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;
}

message Return {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional Expr value = 4;
}

message ReturnIf {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr condition = 4;
  required Expr value = 5;
}

message Case {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Expr condition = 4;
  required Stmt body = 5;
}

message Switch {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  repeated Case cases = 4;
  required Expr condition = 5;
  optional Stmt default_case = 6;
}

message Export {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  repeated Expr attributes = 4;
  required Stmt body = 5;
  required string abi_name = 6;
  required Vis visibility = 7;
}

message Scope {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  repeated string dependencies = 4;
  required Stmt body = 5;
  required string name = 6;
}

message Typedef {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  required Type type = 4;
  required string name = 5;
}

message Enum {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  repeated EnumItem items = 4;
  optional Type base_type = 5;
  required string name = 6;
}

message Function {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional TemplateParameters template_parameters = 4;
  repeated Expr attributes = 5;
  repeated FunctionCapture captures = 6;
  repeated FunctionParameter parameters = 7;
  required Type return_type = 8;
  optional Expr precondition = 9;
  optional Expr postcondition = 10;
  optional Stmt body = 11;
  required string name = 12;
  required FunctionPurity purity = 13;
  required bool is_variadic = 14;
}

message Struct {
  optional SourceLocationRange from = 1;
  repeated UserComment attached_comments = 2;

  optional TemplateParameters template_parameters = 4;
  repeated Expr attributes = 5;
  repeated string names = 6;
  repeated StructField fields = 7;
  repeated StructMethod methods = 8;
  repeated StructMethod static_methods = 9;
  required AggregateKind kind = 10;
  required string name = 11;
}

message Expr {
  oneof node {
    Base base = 1;
    StmtExpr stmt = 2;
    TypeExpr type = 3;
    UnaryExpression unary_expression = 4;
    BinaryExpression binary_expression = 5;
    PostUnaryExpression post_unary_expression = 6;
    TernaryExpression ternary_expression = 7;
    Integer integer = 8;
    Float float = 9;
    Boolean boolean = 10;
    String string = 11;
    Character character = 12;
    Null null = 13;
    Undefined undefined = 14;
    Call call = 15;
    TemplateCall template_call = 16;
    List list = 17;
    Assoc assoc = 18;
    Index index = 19;
    Slice slice = 20;
    FString fstring = 21;
    Identifier identifier = 22;
    Sequence sequence = 23;
  }
}

message Stmt {
  oneof node {
    Base base = 1;
    ExprStmt expr = 2;
    Block block = 3;
    Variable variable = 4;
    Assembly assembly = 5;
    If if = 6;
    While while = 7;
    For for = 8;
    Foreach foreach = 9;
    Break break = 10;
  }
}

message Type {
  oneof node {
    Base base = 1;
    NamedTy named = 2;
    InferTy infer = 3;
    TemplateType template = 4;
    U1 u1 = 5;
    U8 u8 = 6;
    U16 u16 = 7;
    U32 u32 = 8;
    U64 u64 = 9;
    U128 u128 = 10;
    I8 i8 = 11;
    I16 i16 = 12;
    I32 i32 = 13;
    I64 i64 = 14;
    I128 i128 = 15;
    F16 f16 = 16;
    F32 f32 = 17;
    F64 f64 = 18;
    F128 f128 = 19;
    VoidTy void = 20;
    PtrTy ptr = 21;
    OpaqueTy opaque = 22;
    TupleTy tuple = 23;
    ArrayTy array = 24;
    RefTy ref = 25;
    FuncTy func = 26;
  }
}

message Root {
  oneof node {
    Expr expr = 1;
    Stmt stmt = 2;
    Type type = 3;
  }
}
