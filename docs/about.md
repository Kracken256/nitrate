---
layout: page
title: About
permalink: /about/
---

What is J?
---

QUIX is a high-level, statically typed, memory-safe, garbage-collected, high-performance, object-oriented, general-purpose systems programming language designed to be safe, expressive, and performant. QUIX supports runtime reflection, low-level memory access, namespaces, mandatory explicit typing, packed data types, classes, operator overloading, coroutines, default initializers, arbitrary precision math, destructors, and automatic memory management.

QUIX may also be referred to as QUIX.

QUIX is especially well-suited for library development, game development, and systems programming. QUIX is designed to be a modern, safe, and expressive alternative to C++ and Rust.

Why J?
---

1. **Safety**: QUIX is memory-safe and type-safe by default. QUIX has no undefined behavior, no null pointers, no buffer overflows, and no wierd stuff. QUIX is designed to be safe by default, and unsafe code is not supported by the language. All unsafe code must be written in another compatible language and linked to J.
1. **Performance**: QUIX is fast. QUIX is designed to be as fast as C++. Memory is managed automatically using reference counting.
1. **Expressiveness**: QUIX uses human readable keywords. QUIX avoids strange symbols and cryptic syntax. QUIX is designed to be easy to read.
1. **Prety**: C++ is beautiful, but it is not safe. Rust is hideous, but it is safe. Go is nice, but it is limited. QUIX is designed to be safe, pretty, and feature-rich.
1. **Compatibile**: QUIX links to C, C++, Go, and Rust objects out of the box. No need for annoying and ugly bindings or wrappers. There is no overhead when calling C, C++, or Rust functions from J.
1. **Reusability**: Because QUIX plays well with C++, the QUIX standard library is vast. The library contains a lot of useful tools such as Math, File I/O, Networking, Compression, Cryptography (OpenSSL wrapper), and more.
1. **Small Binaries**: QUIX produces small packed binaries. The standard library is modular and unrelated code is not linked into the final binary. If you don't call it, it's not there. Binaries start at ~8KB.