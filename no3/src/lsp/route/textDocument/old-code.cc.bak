
void recurse(npar_node_t* C) {
  /**
   * TODO: Resolve the following issues:
   * - Parentheses are currently lost and the order of sub-expressions is not
   * preserved;
   * - Integer literals loose their original base.
   * - Code comments are lost
   * - Code with macros is not supported
   * - Maximum line width is not supported at all (might me okay)
   */

  using namespace npar;

  if (!C) {
    return;
  }

  switch (C->getKind()) {
    case QAST_BASE: {
      break;
    }

    case QAST_BINEXPR: {
      BinExpr* N = C->as<BinExpr>();
      line << "(";
      recurse(N->get_lhs());
      line << " " << N->get_op() << " ";
      recurse(N->get_rhs());
      line << ")";
      break;
    }

    case QAST_UNEXPR: {
      UnaryExpr* N = C->as<UnaryExpr>();
      line << "(";
      line << N->get_op();
      switch (N->get_op()) {
        case qOpSizeof:
        case qOpBitsizeof:
        case qOpAlignof:
        case qOpTypeof:
          line << "(";
          recurse(N->get_rhs());
          line << ")";
          break;
        default:
          recurse(N->get_rhs());
          break;
      }
      line << ")";
      break;
    }

    case QAST_TEREXPR: {
      TernaryExpr* N = C->as<TernaryExpr>();
      line << "(";
      recurse(N->get_cond());
      line << " ? ";
      recurse(N->get_lhs());
      line << " : ";
      recurse(N->get_rhs());
      line << ")";
      break;
    }

    case QAST_INT: {
      line << C->as<ConstInt>()->get_value();
      break;
    }

    case QAST_FLOAT: {
      write_float_literal(C->as<ConstFloat>()->get_value());
      break;
    }

    case QAST_STRING: {
      escape_string_literal(C->as<ConstString>()->get_value());
      break;
    }

    case QAST_CHAR: {
      ConstChar* N = C->as<ConstChar>();
      line << escape_char_literal(N->get_value());
      break;
    }

    case QAST_BOOL: {
      if (C->as<ConstBool>()->get_value()) {
        line << "true";
      } else {
        line << "false";
      }
      break;
    }

    case QAST_NULL: {
      line << "null";
      break;
    }

    case QAST_UNDEF: {
      line << "undef";
      break;
    }

    case QAST_CALL: {
      Call* N = C->as<Call>();

      recurse(N->get_func());

      line << "(";

      line.seekg(0, std::ios::end);
      size_t line_size = line.tellg();

      size_t split_on = -1, i = 0;

      if (std::any_of(N->get_args().begin(), N->get_args().end(),
                      [](auto x) { return !std::isdigit(x.first.at(0)); })) {
        split_on = 1;
      } else if (N->get_args().size() > 6) {
        split_on = std::ceil(std::sqrt(N->get_args().size()));
      }

      for (auto it = N->get_args().begin(); it != N->get_args().end(); it++) {
        bool is_call = it->second->getKind() == QAST_CALL;
        bool is_other = it->second->getKind() == QAST_LIST ||
                        (it->second->getKind() == QAST_SEXPR &&
                         (it->second->as<StmtExpr>()->get_stmt()->getKind() ==
                          QAST_FUNCTION));

        line.seekg(0, std::ios::end);
        size_t line_width = line.tellg();

        if (!is_call && !is_other) {
          field_indent_stack.push(line_width);
        } else if (is_call) {
          field_indent_stack.push(line_width - tabSize);
        } else if (is_other) {
          indent++;
        }

        if (!std::isdigit(it->first.at(0))) {
          line << it->first;
          line << ": ";
        }
        recurse(it->second);
        i++;

        if (std::next(it) != N->get_args().end()) {
          line << ",";

          if (i % split_on == 0) {
            line << "\n";
            flush_line();
            line << std::string(line_size, ' ');
          } else {
            line << " ";
          }
        }
        if (!is_other) {
          field_indent_stack.pop();
        } else {
          indent--;
        }
      }
      line << ")";

      break;
    }

    case QAST_LIST: {
      List* N = C->as<List>();
      if (N->get_items().empty()) {
        line << "[]";
        break;
      }

      auto ty = N->get_items().front()->getKind();
      if (N->get_items().size() > 0 &&
          (ty == QAST_ASSOC || ty == QAST_LIST ||
           ty == QAST_CALL || ty == QAST_TEMPL_CALL ||
           (ty == QAST_SEXPR &&
            N->get_items().front()->as<StmtExpr>()->get_stmt()->getKind() ==
                QAST_FUNCTION))) {
        line << "[\n";
        flush_line();
        indent++;
        for (auto it = N->get_items().begin(); it != N->get_items().end();
             it++) {
          put_indent();
          recurse(*it);
          line << ",\n";
          flush_line();
        }
        indent--;
        put_indent();
        line << "]";
      } else {
        size_t split_on = N->get_items().size() <= 8
                              ? 8
                              : std::ceil(std::sqrt(N->get_items().size()));

        line << "[";

        line.seekg(0, std::ios::end);
        size_t line_size = line.tellg();

        size_t i = 0;
        for (auto it = N->get_items().begin(); it != N->get_items().end();
             it++) {
          recurse(*it);

          i++;
          if (std::next(it) != N->get_items().end()) {
            line << ",";
            if (i % split_on == 0) {
              line << "\n";
              flush_line();
              line << std::string(line_size, ' ');
            } else {
              line << " ";
            }
          }
        }
        line << "]";
      }
      break;
    }

    case QAST_ASSOC: {
      Assoc* N = C->as<Assoc>();
      line << "{";
      recurse(N->get_key());
      line << ": ";
      recurse(N->get_value());
      line << "}";
      break;
    }

    case QAST_FIELD: {
      Field* N = C->as<Field>();
      bool break_chain_call = false;

      if (N->get_base()->getKind() == QAST_CALL) {
        break_chain_call = true;
      }

      recurse(N->get_base());

      if (break_chain_call) {
        line << "\n";
        flush_line();
        qcore_assert(field_indent_stack.top() > 0);
        line << std::string((indent * tabSize) + field_indent_stack.top(), ' ');
      } else {
        line.seekg(0, std::ios::end);
        size_t line_width = line.tellg();

        field_indent_stack.top() = line_width;
      }

      line << "." << N->get_field();

      break;
    }

    case QAST_INDEX: {
      Index* N = C->as<Index>();
      recurse(N->get_base());
      line << "[";
      recurse(N->get_index());
      line << "]";
      break;
    }

    case QAST_SLICE: {
      Slice* N = C->as<Slice>();
      recurse(N->get_base());
      line << "[";
      recurse(N->get_start());
      line << ":";
      recurse(N->get_end());
      line << "]";
      break;
    }

    case QAST_FSTRING: {
      FString* N = C->as<FString>();
      line << "f\"";
      for (auto it = N->get_items().begin(); it != N->get_items().end(); it++) {
        if (std::holds_alternative<String>(*it)) {
          escape_string_literal_chunk(std::get<String>(*it));
        } else {
          line << "{";
          std::stringstream swap_line, swap_buffer;
          std::swap(line, swap_line);
          std::swap(file, swap_buffer);

          recurse(std::get<Expr*>(*it));

          std::swap(file, swap_buffer);
          std::swap(line, swap_line);

          swap_buffer << swap_line.str();

          escape_string_literal_chunk(swap_buffer.str());
          line << "}";
        }
      }
      line << "\"";
      break;
    }

    case QAST_IDENT: {
      line << C->as<Ident>()->get_name();
      break;
    }

    case QAST_SEQ: {
      SeqPoint* N = C->as<SeqPoint>();

      line << "(";
      for (auto it = N->get_items().begin(); it != N->get_items().end(); it++) {
        recurse(*it);

        if (std::next(it) != N->get_items().end()) {
          line << ", ";
        }
      }
      line << ")";
      break;
    }

    case QAST_POST_UNEXPR: {
      PostUnaryExpr* N = C->as<PostUnaryExpr>();
      line << "(";
      recurse(N->get_lhs());
      line << N->get_op() << ")";
      break;
    }

    case QAST_SEXPR: {
      recurse(C->as<StmtExpr>()->get_stmt());
      break;
    }

    case QAST_TEXPR: {
      recurse(C->as<TypeExpr>()->get_type());
      break;
    }

    case QAST_TEMPL_CALL: {
      TemplCall* N = C->as<TemplCall>();

      recurse(N->get_func());

      line << "<";
      for (auto it = N->get_template_args().begin();
           it != N->get_template_args().end(); it++) {
        if (!std::isdigit(it->first.at(0))) {
          line << it->first;
          line << ": ";
        }
        recurse(it->second);

        if (std::next(it) != N->get_template_args().end()) {
          line << ", ";
        }
      }
      line << ">";

      line << "(";
      for (auto it = N->get_args().begin(); it != N->get_args().end(); it++) {
        if (!std::isdigit(it->first.at(0))) {
          line << it->first;
          line << ": ";
        }
        recurse(it->second);

        if (std::next(it) != N->get_args().end()) {
          line << ", ";
        }
      }
      line << ")";

      break;
    }

    case QAST_REF: {
      line << "&";
      recurse(C->as<RefTy>()->get_item());
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_U1: {
      line << "u1";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_U8: {
      line << "u8";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_U16: {
      line << "u16";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_U32: {
      line << "u32";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_U64: {
      line << "u64";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_U128: {
      line << "u128";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_I8: {
      line << "i8";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_I16: {
      line << "i16";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_I32: {
      line << "i32";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_I64: {
      line << "i64";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_I128: {
      line << "i128";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_F16: {
      line << "f16";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_F32: {
      line << "f32";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_F64: {
      line << "f64";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_F128: {
      line << "f128";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_VOID: {
      line << "void";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_PTR: {
      line << "*";
      recurse(C->as<PtrTy>()->get_item());
      break;
    }

    case QAST_OPAQUE: {
      line << "opaque(" << C->as<OpaqueTy>()->get_name() << ")";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_ARRAY: {
      ArrayTy* N = C->as<ArrayTy>();
      line << "[";
      recurse(N->get_item());
      line << "; ";
      recurse(N->get_size());
      line << "]";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_TUPLE: {
      TupleTy* N = C->as<TupleTy>();

      line << "(";
      for (auto it = N->get_items().begin(); it != N->get_items().end(); ++it) {
        recurse(*it);

        if (std::next(it) != N->get_items().end()) {
          line << ", ";
        }
      }
      line << ")";

      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_FUNCTOR: {
      static const std::unordered_map<FuncPurity, std::string> purity_str = {
          {FuncPurity::IMPURE_THREAD_UNSAFE, ""},
          {FuncPurity::IMPURE_THREAD_SAFE, " tsafe"},
          {FuncPurity::PURE, " pure"},
          {FuncPurity::QUASI, " quasi"},
          {FuncPurity::RETRO, " retro"}};

      FuncTy* N = C->as<FuncTy>();

      std::string props;
      props += purity_str.at(N->get_purity());

      if (N->is_()) {
        props += " ";
      }

      line << "fn";
      if (!props.empty()) {
        line << std::move(props);
      }

      line << "(";
      for (auto it = N->get_params().begin(); it != N->get_params().end();
           it++) {
        line << std::get<0>(*it);
        auto param_ty = std::get<1>(*it);
        if ((param_ty && param_ty->getKind() != QAST_INFER) ||
            std::get<2>(*it)) {
          line << ": ";
          recurse(std::get<1>(*it));
          if (std::get<2>(*it)) {
            line << " = ";
            recurse(std::get<2>(*it));
          }
        }

        if (std::next(it) != N->get_params().end() || N->is_variadic()) {
          line << ", ";
        }
      }

      if (N->is_variadic()) {
        line << "...";
      }

      line << ")";

      if (N->get_return() &&
          N->get_return()->getKind() != QAST_VOID) {
        line << ": ";
        recurse(N->get_return());
      }

      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_NAMED: {
      line << C->as<NamedTy>()->get_name();
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_INFER: {
      line << "?";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_TEMPLATE: {
      TemplType* N = C->as<TemplType>();

      if (N->get_template()->getKind() == QAST_NAMED) {
        auto name = N->get_template()->as<NamedTy>()->get_name();

        if (name == "__builtin_result") {
          qcore_assert(N->get_args().size() == 1);
          recurse(N->get_args().front());
          line << "?";

          put_type_metadata(C->as<npar::Type>());
          break;
        } else if (name == "__builtin_vec") {
          qcore_assert(N->get_args().size() == 1);

          line << "[";
          recurse(N->get_args().front());
          line << "]";

          put_type_metadata(C->as<npar::Type>());
          break;
        } else if (name == "__builtin_uset") {
          qcore_assert(N->get_args().size() == 1);

          line << "{";
          recurse(N->get_args().front());
          line << "}";

          put_type_metadata(C->as<npar::Type>());
          break;
        } else if (name == "__builtin_umap") {
          qcore_assert(N->get_args().size() == 2);

          line << "[";
          recurse(N->get_args()[0]);
          line << "->";
          recurse(N->get_args()[1]);
          line << "]";

          put_type_metadata(C->as<npar::Type>());
          break;
        }
      }

      recurse(N->get_template());
      line << "<";
      for (auto it = N->get_args().begin(); it != N->get_args().end(); ++it) {
        recurse(*it);

        if (std::next(it) != N->get_args().end()) {
          line << ", ";
        }
      }
      line << ">";
      put_type_metadata(C->as<npar::Type>());
      break;
    }

    case QAST_TYPEDEF: {
      TypedefStmt* N = C->as<TypedefStmt>();
      line << "type " << N->get_name() << " = ";
      recurse(N->get_type());
      break;
    }

    case QAST_STRUCT: {
      line << "struct";
      put_composite_defintion(C->as<StructDef>());
      break;
    }

    case QAST_ENUM: {
      EnumDef* N = C->as<EnumDef>();
      line << "enum " << N->get_name();

      if (N->get_type()) {
        line << ": ";
        recurse(N->get_type());
        line << " ";
      } else {
        line << " ";
      }

      if (N->get_items().empty()) {
        line << "{}";
        break;
      }

      line << "{\n";
      flush_line();
      indent++;

      for (auto it = N->get_items().begin(); it != N->get_items().end(); it++) {
        put_indent();

        line << it->first;
        if (it->second) {
          line << " = ";
          recurse(it->second);
        }

        line << ",\n";
        flush_line();
      }

      indent--;
      put_indent();
      line << "}";

      break;
    }

    case QAST_FUNCTION: {
      static const std::unordered_map<FuncPurity, std::string> purity_str = {
          {FuncPurity::IMPURE_THREAD_UNSAFE, ""},
          {FuncPurity::IMPURE_THREAD_SAFE, " tsafe"},
          {FuncPurity::PURE, " pure"},
          {FuncPurity::QUASI, " quasi"},
          {FuncPurity::RETRO, " retro"}};

      FnDef* N = C->as<FnDef>();
      FuncTy* F = N->get_type();
      if (!F) {
        break;
      }

      std::string props;
      props += purity_str.at(F->get_purity());

      if (F->is_()) {
        props += " ";
      }

      if (!N->get_name().empty()) {
        props += " " + N->get_name();
      }

      line << "fn";
      if (!props.empty()) {
        line << std::move(props);
      }

      line << "(";
      for (auto it = F->get_params().begin(); it != F->get_params().end();
           it++) {
        if (std::get<0>(*it) == "this") {
          continue;
        }

        line << std::get<0>(*it);
        auto param_ty = std::get<1>(*it);
        if ((param_ty && param_ty->getKind() != QAST_INFER) ||
            std::get<2>(*it)) {
          line << ": ";
          recurse(std::get<1>(*it));
          if (std::get<2>(*it)) {
            line << " = ";
            recurse(std::get<2>(*it));
          }
        }

        if (std::next(it) != F->get_params().end() || F->is_variadic()) {
          line << ", ";
        }
      }

      if (F->is_variadic()) {
        line << "...";
      }

      line << ")";

      if (F->get_return() &&
          F->get_return()->getKind() != QAST_VOID) {
        line << ": ";
        recurse(F->get_return());
      }
      line << " ";

      {
        recurse(N->get_body());

        bool promises = N->get_precond() || N->get_postcond();
        if (promises) {
          line << " promise {\n";
          flush_line();
          indent++;
          if (N->get_precond()) {
            put_indent();
            line << "in ";
            recurse(N->get_precond());
            line << ";\n";
            flush_line();
          }

          if (N->get_postcond()) {
            put_indent();
            line << "out ";
            recurse(N->get_postcond());
            line << ";\n";
            flush_line();
          }
          indent--;
          line << "}";
        }
      }

      break;
    }

    case QAST_SCOPE: {
      ScopeStmt* N = C->as<ScopeStmt>();
      line << "scope " << N->get_name();

      if (!N->get_deps().empty()) {
        line << ": [";
        for (auto it = N->get_deps().begin(); it != N->get_deps().end(); it++) {
          line << *it;
          if (std::next(it) != N->get_deps().end()) {
            line << ", ";
          }
        }
        line << "]";
      }

      line << " ";

      recurse(N->get_body());

      break;
    }

    case QAST_EXPORT: {
      // ExportStmt* N = C->as<ExportStmt>();
      // std::vector<Stmt*> imports, exports;

      qcore_implement();

      // for (auto it = N->get_body()->get_items().begin();
      //      it != N->get_body()->get_items().end(); it++) {
      //   npar_ty_t ty = (*it)->getKind();

      //   if (ty == QAST_FUNCTION) {
      //     exports.push_back(*it);
      //   } else if (ty == QAST_VAR) {
      //     VarDecl* V = (*it)->as<VarDecl>();
      //     V->get_value() ? exports.push_back(*it) : imports.push_back(*it);
      //   } else if (ty == QAST_VAR) {
      //     VarDecl* V = (*it)->as<VarDecl>();
      //     V->get_value() ? exports.push_back(*it) : imports.push_back(*it);
      //   }
      // }

      // if (imports.size() == 1) {
      //   line << "import ";
      //   if (N->get_abi_name().empty()) {
      //     line << "\"std\"";
      //   } else {
      //     escape_string_literal( N->get_abi_name());
      //   }
      //   line << " ";

      //   recurse(imports.front());
      //   line << ";";
      // } else if (!imports.empty()) {
      //   line << "import ";
      //   if (N->get_abi_name().empty()) {
      //     line << "\"std\"";
      //   } else {
      //     escape_string_literal( N->get_abi_name());
      //   }
      //   line << " {\n";
      //   flush_line();
      //   indent++;

      //   for (auto& stmt : imports) {
      //     put_indent();
      //     recurse(stmt);
      //     line << ";\n";
      //     flush_line();
      //   }

      //   indent--;
      //   put_indent();

      //   line << "}";
      // }

      // if (exports.size() == 1) {
      //   line << "pub ";
      //   if (N->get_abi_name().empty()) {
      //     line << "\"std\"";
      //   } else {
      //     escape_string_literal( N->get_abi_name());
      //   }
      //   line << " ";

      //   recurse(exports.front());
      //   if (exports.front()->getKind() != QAST_FUNCTION) {
      //     line << ";";
      //   }
      // } else if (!exports.empty()) {
      //   line << "pub ";
      //   if (N->get_abi_name().empty()) {
      //     line << "\"std\"";
      //   } else {
      //     escape_string_literal( N->get_abi_name());
      //   }
      //   line << " {\n";
      //   flush_line();
      //   indent++;

      //   for (auto& stmt : exports) {
      //     put_indent();
      //     recurse(stmt);
      //     line << ";\n";
      //     flush_line();
      //   }

      //   indent--;
      //   put_indent();

      //   line << "}";
      // }

      break;
    }

    case QAST_BLOCK: {
      static const std::unordered_set<npar_ty_t> no_has_semicolon = {
          QAST_FUNCTION,
          QAST_EXPORT,
          QAST_BLOCK,
      };

      static const std::unordered_set<npar_ty_t> double_sep = {
          QAST_STRUCT, QAST_ENUM,  QAST_FUNCTION,
          QAST_SCOPE,  QAST_EXPORT, QAST_BLOCK,
      };

      Block* N = C->as<Block>();

      bool did_root = did_root;
      did_root = true;

      if (did_root && N->get_items().empty() &&
          N->get_safety() == SafetyMode::Unknown) {
        line << "{}";
        break;
      }

      if (N->get_safety() == SafetyMode::Unsafe) {
        if (N->get_items().empty()) {
          break;
        }

        line << "/* UNS"
                "AFE: */ unsafe ";

        if (N->get_items().size() == 1) {
          Stmt* stmt = N->get_items()[0];
          recurse(stmt);
          if (!no_has_semicolon.contains(stmt->getKind())) {
            line << ";";
          }

          break;
        }
      } else if (N->get_safety() == SafetyMode::Safe) {
        if (N->get_items().empty()) {
          break;
        }

        line << "safe ";

        if (N->get_items().size() == 1) {
          Stmt* stmt = N->get_items()[0];
          recurse(stmt);
          if (!no_has_semicolon.contains(stmt->getKind())) {
            line << ";";
          }

          break;
        }
      }

      if (did_root) {
        line << "{\n";
        flush_line();
        indent++;
      }

      for (auto it = N->get_items().begin(); it != N->get_items().end(); ++it) {
        npar_ty_t ty = (*it)->getKind();

        put_indent();
        recurse(*it);
        if (!no_has_semicolon.contains(ty)) {
          line << ";";
        }

        bool do_double_line = double_sep.contains((*it)->getKind()) ||
                              (std::next(it) != N->get_items().end() &&
                               (*std::next(it))->getKind() != ty);

        if (std::next(it) != N->get_items().end() && do_double_line) {
          line << "\n\n";
          flush_line();
        } else {
          line << "\n";
          flush_line();
        }
      }

      if (did_root) {
        indent--;
        put_indent();
        line << "}";
      } else {
        flush_line();
      }

      break;
    }

    case QAST_VAR: {
      VarDecl* N = C->as<VarDecl>();
      line << "var " << N->get_name();
      if (N->get_type()) {
        line << ": ";
        recurse(N->get_type());
      }
      if (N->get_value()) {
        line << " = ";
        recurse(N->get_value());
      }
      break;
    }

    case QAST_INLINE_ASM: {
      qcore_panic("Asm format is not implemented");
      break;
    }

    case QAST_RETURN: {
      ReturnStmt* N = C->as<ReturnStmt>();

      line << "ret";
      if (N->get_value()) {
        line << " ";
        recurse(N->get_value().value());
      }

      break;
    }

    case QAST_RETIF: {
      ReturnIfStmt* N = C->as<ReturnIfStmt>();

      line << "retif ";
      recurse(N->get_cond());
      line << ", ";
      recurse(N->get_value());

      break;
    }

    case QAST_BREAK: {
      line << "break";
      break;
    }

    case QAST_CONTINUE: {
      line << "continue";
      break;
    }

    case QAST_IF: {
      IfStmt* N = C->as<IfStmt>();

      line << "if ";
      recurse(N->get_cond());

      line << " ";
      recurse(N->get_then());

      if (N->get_else()) {
        line << " else ";
        recurse(N->get_else());
      }

      break;
    }

    case QAST_WHILE: {
      WhileStmt* N = C->as<WhileStmt>();
      line << "while ";
      recurse(N->get_cond());
      line << " ";

      recurse(N->get_body());
      break;
    }

    case QAST_FOR: {
      ForStmt* N = C->as<ForStmt>();
      line << "for (";

      recurse(N->get_init());
      line << ";";
      if (N->get_init()) line << " ";

      recurse(N->get_cond());
      line << ";";
      if (N->get_cond()) line << " ";

      recurse(N->get_step());

      line << ") ";

      recurse(N->get_body());
      break;
    }

    case QAST_FOREACH: {
      ForeachStmt* N = C->as<ForeachStmt>();
      line << "foreach (" << N->get_idx_ident() << ", " << N->get_val_ident()
           << " in ";
      recurse(N->get_expr());

      line << ") ";

      recurse(N->get_body());
      break;
    }

    case QAST_CASE: {
      CaseStmt* N = C->as<CaseStmt>();
      line << "case ";
      recurse(N->get_cond());
      line << ": ";
      recurse(N->get_body());
      break;
    }

    case QAST_SWITCH: {
      SwitchStmt* N = C->as<SwitchStmt>();
      line << "switch ";
      recurse(N->get_cond());
      if (N->get_cases().empty() && !N->get_default()) {
        line << " {}";
      } else {
        line << " {\n";
        flush_line();
        indent++;
        for (auto& stmt : N->get_cases()) {
          put_indent();
          recurse(stmt);
          line << "\n";
          flush_line();
        }
        if (N->get_default()) {
          put_indent();
          line << "default: ";
          recurse(N->get_default());
          line << "\n";
          flush_line();
        }
        indent--;
        put_indent();
        line << "}";
      }
      break;
    }

    case QAST_ESTMT: {
      recurse(C->as<ExprStmt>()->get_expr());
      break;
    }
  }
}
