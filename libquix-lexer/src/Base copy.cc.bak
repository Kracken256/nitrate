////////////////////////////////////////////////////////////////////////////////
///                                                                          ///
///  ░▒▓██████▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓██████▓▒░ ░▒▓██████▓▒░  ///
/// ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ ///
/// ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░        ///
/// ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓██████▓▒░░▒▓█▓▒░      ░▒▓█▓▒░        ///
/// ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░        ///
/// ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ ///
///  ░▒▓██████▓▒░ ░▒▓██████▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓██████▓▒░ ░▒▓██████▓▒░  ///
///    ░▒▓█▓▒░                                                               ///
///     ░▒▓██▓▒░                                                             ///
///                                                                          ///
///   * QUIX LANG COMPILER - The official compiler for the Quix language.    ///
///   * Copyright (C) 2024 Wesley C. Jones                                   ///
///                                                                          ///
///   The QUIX Compiler Suite is free software; you can redistribute it or   ///
///   modify it under the terms of the GNU Lesser General Public             ///
///   License as published by the Free Software Foundation; either           ///
///   version 2.1 of the License, or (at your option) any later version.     ///
///                                                                          ///
///   The QUIX Compiler Suite is distributed in the hope that it will be     ///
///   useful, but WITHOUT ANY WARRANTY; without even the implied warranty of ///
///   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU      ///
///   Lesser General Public License for more details.                        ///
///                                                                          ///
///   You should have received a copy of the GNU Lesser General Public       ///
///   License along with the QUIX Compiler Suite; if not, see                ///
///   <https://www.gnu.org/licenses/>.                                       ///
///                                                                          ///
////////////////////////////////////////////////////////////////////////////////

#define __QUIX_IMPL__

#include <quix-core/Error.h>
#include <quix-lexer/Lexer.h>
#include <string.h>

#include <array>
#include <boost/bimap.hpp>
#include <boost/unordered_map.hpp>
#include <cctype>
#include <charconv>
#include <cmath>
#include <csetjmp>
#include <cstdio>
#include <iomanip>
#include <queue>
#include <quix-lexer/Base.hh>
#include <string>
#include <string_view>
#include <utility>
#include <vector>

#include "LibMacro.h"

///============================================================================///
/// BEGIN: LEXICAL GRAMMAR CONSTRAINTS
#define FLOATING_POINT_PRECISION 128
/// END:   LEXICAL GRAMMAR CONSTRAINTS
///============================================================================///

///============================================================================///
/// BEGIN: PERFORMANCE HYPER PARAMETERS
#define GETC_BUFFER_SIZE 64
#define TOKEN_BUF_SIZE 64
/// END:   PERFORMANCE HYPER PARAMETERS
///============================================================================///


enum class NumType {
  Invalid,
  Decimal,
  DecimalExplicit,
  Hexadecimal,
  Binary,
  Octal,
  Floating,
};

#if MEMORY_OVER_SPEED
class StringRetainer {
  boost::unordered_map<uint8_t, std::vector<std::string>> m_strings;

#define BIN_ID(x) (x & 0x7)
#define INDEX_ID(x) (x >> 3)

#define CONV_ID(bin, idx) (((idx) << 3) | (bin))

  uint8_t size_to_bignum(size_t size) {
    if (size <= 2) return 0;
    if (size <= 4) return 1;
    if (size <= 6) return 2;
    if (size <= 8) return 3;
    if (size <= 10) return 4;
    if (size <= 16) return 5;
    if (size <= 128) return 6;
    return 7;
  }

public:
  StringRetainer() {
    for (uint8_t i = 0; i < 8; i++) {
      m_strings[i] = std::vector<std::string>();
    }
  }

  inline qlex_size retain(std::string_view str) {
    uint8_t bin_num = size_to_bignum(str.size());

    auto it = std::find(m_strings[bin_num].begin(), m_strings[bin_num].end(), str);

    if (it == m_strings[bin_num].end()) {
      m_strings[bin_num].push_back(std::string(str));
      return CONV_ID(bin_num, m_strings[bin_num].size() - 1);
    }

    return CONV_ID(bin_num, std::distance(m_strings[bin_num].begin(), it));
  }

  inline void release(qlex_size idx) {
    m_strings.at(BIN_ID(idx)).at(INDEX_ID(idx)).clear();
    m_strings.at(BIN_ID(idx)).at(INDEX_ID(idx)).shrink_to_fit();
  }

  inline std::string_view operator[](qlex_size idx) const {
    return m_strings.at(BIN_ID(idx)).at(INDEX_ID(idx));
  }
};
#else
class StringRetainer {
  std::vector<std::string> m_strings;

public:
  StringRetainer() = default;

  inline qlex_size retain(std::string_view str) {
    m_strings.push_back(std::string(str.data(), str.size()));
    return m_strings.size() - 1;
  }

  inline void release(qlex_size idx) { m_strings[idx].clear(); }

  inline std::string_view at(qlex_size idx) const { return m_strings.at(idx); }
};
#endif

struct qlex_impl_t : public qlex_t {
private:
  size_t m_tok_pos;
  size_t m_bufpos;
  qlex_size m_locctr;
  StringRetainer m_holdings;

  std::deque<char> m_pushback;
  std::queue<qlex_tok_t> m_undo;
  boost::unordered_map<qlex_size, clever_me_t> m_tag_to_loc;
  boost::unordered_map<qlex_size, qlex_size> m_tag_to_off;

  std::array<char, GETC_BUFFER_SIZE> m_buf;
  std::array<qlex_tok_t, TOKEN_BUF_SIZE> m_tokens;

  void refill_buffer();
  qlex_tok_t do_automata() noexcept;
  void reset_state();

  char getc();

  qlex_loc_t loc() {
    static_assert(sizeof(bits) == sizeof(qlex_size));

    if (m_row <= 2097152 || m_col <= 1024) {
      clever_me_t bits;

      bits.rc_fmt = 1;
      bits.col = m_col;
      bits.row = m_row;

      qlex_size tag = m_locctr++;
      m_tag_to_loc[tag] = bits;
      m_tag_to_off[tag] = m_offset;

      return {tag};
    } else {
      return {0};
    }
  }

  protected:
    

public:
  qlex_impl_t(FILE *file, bool is_owned)
      : m_tok_pos(TOKEN_BUF_SIZE + 1),
        m_bufpos(GETC_BUFFER_SIZE),
        m_row(1),
        m_col(1),
        m_offset(0),
        m_locctr(1),  // 0 means invalid location
        m_holdings(),

        m_file(file),
        m_is_owned(is_owned) {
    if (fseek(file, 0, SEEK_SET) != 0) {
      qcore_panic("qlex_impl_t::LexerState: failed to seek to start of file");
    }
  }

  ~qlex_impl_t() {
    qcore_assert(m_file, "qlex_impl_t::~LexerState: file is NULL. Double free?");

    if (m_is_owned) {
      fclose(m_file);
    }
  }

  const StringRetainer &Strings() const { return m_holdings; }

  qlex_tok_t next();

  void undo(qlex_tok_t tok) { m_undo.push(tok); }
  qlex_size save_userstring(std::string_view str) { return m_holdings.retain(str); }

  std::optional<qlex_size> loc2offset(qlex_loc_t loc) {
    if (m_tag_to_off.find(loc.tag) == m_tag_to_off.end()) [[unlikely]] {
      return std::nullopt;
    }

    return m_tag_to_off[loc.tag];
  }

  std::optional<std::pair<qlex_size, qlex_size>> loc2rowcol(qlex_loc_t loc) {
    if (m_tag_to_loc.find(loc.tag) == m_tag_to_loc.end()) [[unlikely]] {
      return std::nullopt;
    }

    clever_me_t it = m_tag_to_loc[loc.tag];

    if (!it.rc_fmt) [[unlikely]] {
      return std::nullopt;
    }

    qlex_size row = it.row;
    qlex_size col = it.col;

    return std::make_pair(row, col);
  }

  qlex_loc_t makeLoc(qlex_size row, qlex_size col, qlex_size offset) {
    clever_me_t bits;
    static_assert(sizeof(bits) == sizeof(qlex_size));

    if (row <= 2097152 || col <= 1024) {
      bits.rc_fmt = 1;
      bits.col = col;
      bits.row = row;

    } else {
      bits.rc_fmt = 0;
    }

    qlex_size tag = m_locctr++;
    m_tag_to_loc[tag] = bits;
    m_tag_to_off[tag] = offset;

    return {tag};
  }

  FILE *file() { return m_file; }
};

///============================================================================///

static qlex_tok_t _impl_peek(qlex_t *self) {
  if (self->cur.ty != qErro) {
    return self->cur;
  }

  do {
    self->cur = inner(self)->next();
  } while (self->flags & QLEX_NO_COMMENTS && self->cur.ty == qNote);

  return self->cur;
}

static void _impl_push(qlex_t *self, const qlex_tok_t *tok) {
  inner(self)->undo(*tok);
  self->cur.ty = qErro;
}

static void _impl_collect(qlex_t *self, const qlex_tok_t *tok) {
  (void)self;
  (void)tok;
}

static void _impl_destruct(qlex_t *self) {
  delete inner(self);
  self->inner = nullptr;
}

///============================================================================///

LIB_EXPORT qlex_t *qlex_new(FILE *file, const char *filename) {
  try {
    qcore_assert(file, "qlex_new: file is NULL");

    if (!filename) {
      filename = "<unknown>";
    }

    qlex_t *lexer = new qlex_t;
    lexer->inner = new qlex_impl_t(file, false);
    lexer->peek = _impl_peek;
    lexer->push = _impl_push;
    lexer->collect = _impl_collect;
    lexer->destruct = _impl_destruct;
    lexer->cur.ty = qErro;
    lexer->flags = QLEX_FLAG_NONE;
    lexer->filename = filename;

    return lexer;
  } catch (std::bad_alloc &) {
    return nullptr;
  } catch (...) {
    qcore_panic("qlex_new: failed to create lexer");
  }
}

LIB_EXPORT qlex_t *qlex_istream__libextra(qlex_cxx_std_istream_t istream, const char *filename) {
  (void)istream;
  (void)filename;

  qcore_implement(__func__);
}

LIB_EXPORT qlex_t *qlex_direct(const char *src, size_t len, const char *filename) {
  try {
    if (!filename) {
      filename = "<unknown>";
    }

    FILE *file = fmemopen((void *)src, len, "r");
    if (!file) {
      return nullptr;
    }

    qlex_t *lexer = new qlex_t;
    lexer->inner = new qlex_impl_t(file, true);
    lexer->peek = _impl_peek;
    lexer->push = _impl_push;
    lexer->collect = _impl_collect;
    lexer->destruct = _impl_destruct;
    lexer->cur.ty = qErro;
    lexer->flags = QLEX_FLAG_NONE;
    lexer->filename = filename;

    return lexer;
  } catch (std::bad_alloc &) {
    return nullptr;
  } catch (...) {
    return nullptr;
  }
}

LIB_EXPORT void qlex_free(qlex_t *lexer) {
  try {
    if (!lexer) {
      return;
    }

    lexer->destruct(lexer);

    delete lexer;
  } catch (...) {
    qcore_panic("qlex_free: failed to free lexer");
  }
}

LIB_EXPORT qlex_tok_t qlex_next(qlex_t *self) {
  qlex_tok_t tok = qlex_peek(self);
  self->cur.ty = qErro;
  return tok;
}

LIB_EXPORT void qlex_set_flags(qlex_t *lexer, qlex_flags_t flags) { lexer->flags = flags; }

LIB_EXPORT qlex_flags_t qlex_get_flags(qlex_t *lexer) { return lexer->flags; }

LIB_EXPORT void qlex_collect(qlex_t *lexer, const qlex_tok_t *tok) { lexer->collect(lexer, tok); }

LIB_EXPORT qlex_tok_t qlex_peek(qlex_t *lexer) { return lexer->peek(lexer); }

LIB_EXPORT void qlex_push(qlex_t *lexer, qlex_tok_t tok) { lexer->push(lexer, &tok); }

LIB_EXPORT const char *qlex_filename(qlex_t *lexer) { return lexer->filename; }

LIB_EXPORT qlex_size qlex_line(qlex_t *lexer, qlex_loc_t loc) {
  try {
    auto r = inner(lexer)->loc2rowcol(loc);
    if (!r) {
      return UINT32_MAX;
    }

    return r->first;
  } catch (...) {
    qcore_panic("qlex_line: failed to get line number");
  }
}

LIB_EXPORT qlex_size qlex_col(qlex_t *lexer, qlex_loc_t loc) {
  try {
    auto r = inner(lexer)->loc2rowcol(loc);
    if (!r) {
      return UINT32_MAX;
    }

    return r->second;
  } catch (...) {
    qcore_panic("qlex_col: failed to get column number");
  }
}

LIB_EXPORT char *qlex_snippet(qlex_t *lexer, qlex_tok_t tok, qlex_size *offset) {
  try {
#define SNIPPET_SIZE 100

    qlex_size tok_beg_offset;
    char snippet_buf[SNIPPET_SIZE];
    qlex_size tok_size = qlex_tok_size(lexer, &tok);
    size_t curpos, seek_base_pos, read;

    { /* Convert the location to an offset into the source */
      auto src_offset_opt = inner(lexer)->loc2offset(tok.start);
      if (!src_offset_opt) {
        return nullptr; /* Return early if translation failed */
      }

      tok_beg_offset = *src_offset_opt - tok_size - 1;
    }

    { /* Calculate offsets and seek to the correct position */
      curpos = ftell(inner(lexer)->file());
      seek_base_pos = tok_beg_offset < SNIPPET_SIZE / 2 ? 0 : tok_beg_offset - SNIPPET_SIZE / 2;

      if (fseek(inner(lexer)->file(), seek_base_pos, SEEK_SET) != 0) {
        fseek(inner(lexer)->file(), curpos, SEEK_SET);
        return nullptr;
      }
    }

    { /* Read the snippet and calculate token offset */
      read = fread(snippet_buf, 1, SNIPPET_SIZE, inner(lexer)->file());

      if (tok_beg_offset < SNIPPET_SIZE / 2) {
        *offset = tok_beg_offset;
      } else {
        *offset = SNIPPET_SIZE / 2;
      }
    }

    // Extract the line that contains the token
    qlex_size lstart = 0;

    for (size_t i = 0; i < read; i++) {
      if (snippet_buf[i] == '\n') {
        lstart = i + 1;
      } else if (i == *offset) { /* Danger ?? */
        qlex_size count = (i - lstart) + tok_size;
        char *output = (char *)malloc(count + 1);
        memcpy(output, snippet_buf + lstart, count);
        output[count] = '\0';
        *offset -= lstart;
        fseek(inner(lexer)->file(), curpos, SEEK_SET);
        return output;
      }
    }

    fseek(inner(lexer)->file(), curpos, SEEK_SET);
    return nullptr;
  } catch (std::bad_alloc &) {
    return nullptr;
  } catch (...) {
    qcore_panic("qlex_snippet: failed to get snippet");
  }
}

LIB_EXPORT qlex_loc_t qlex_offset(qlex_t *lexer, qlex_loc_t base, qlex_size offset) {
  try {
    long curpos;
    std::optional<qlex_size> seek_base_pos;
    uint8_t *buf = nullptr;
    size_t bufsz;

    if (!(seek_base_pos = inner(lexer)->loc2offset(base))) {
      return base;
    }

    if ((curpos = ftell(inner(lexer)->file())) == -1) {
      return base;
    }

    if (fseek(inner(lexer)->file(), *seek_base_pos + offset, SEEK_SET) != 0) {
      return base;
    }

    bufsz = offset;

    if ((buf = (uint8_t *)malloc(bufsz + 1)) == nullptr) {
      fseek(inner(lexer)->file(), curpos, SEEK_SET);
      return base;
    }

    if (fread(buf, 1, bufsz, inner(lexer)->file()) != bufsz) {
      free(buf);
      fseek(inner(lexer)->file(), curpos, SEEK_SET);
      return base;
    }

    buf[bufsz] = '\0';
    fseek(inner(lexer)->file(), curpos, SEEK_SET);

    //===== AUTOMATA TO CALCULATE THE NEW ROW AND COLUMN =====//
    uint32_t row, col;

    if ((row = qlex_line(lexer, base)) == UINT32_MAX) {
      free(buf);
      return base;
    }

    if ((col = qlex_col(lexer, base)) == UINT32_MAX) {
      free(buf);
      return base;
    }

    for (size_t i = 0; i < bufsz; i++) {
      if (buf[i] == '\n') {
        row++;
        col = 1;
      } else {
        col++;
      }
    }

    free(buf);

    return inner(lexer)->makeLoc(row, col, *seek_base_pos + offset);
  } catch (...) {
    qcore_panic("qlex_offset: failed to calculate offset");
  }
}

LIB_EXPORT qlex_size qlex_span(qlex_t *lexer, qlex_loc_t start, qlex_loc_t end) {
  try {
    std::optional<qlex_size> begoff, endoff;

    if (!(begoff = inner(lexer)->loc2offset(start))) {
      return UINT32_MAX;
    }

    if (!(endoff = inner(lexer)->loc2offset(end))) {
      return UINT32_MAX;
    }

    if (*endoff < *begoff) {
      return 0;
    }

    return *endoff - *begoff;
  } catch (...) {
    qcore_panic("qlex_span: failed to calculate span");
  }
}

LIB_EXPORT qlex_size qlex_spanx(qlex_t *lexer, qlex_loc_t start, qlex_loc_t end,
                                void (*callback)(const char *, qlex_size, uintptr_t),
                                uintptr_t userdata) {
  try {
    std::optional<qlex_size> begoff, endoff;

    if (!(begoff = inner(lexer)->loc2offset(start))) {
      return UINT32_MAX;
    }

    if (!(endoff = inner(lexer)->loc2offset(end))) {
      return UINT32_MAX;
    }

    if (*endoff < *begoff) {
      return 0;
    }

    qlex_size span = *endoff - *begoff;

    long curpos;
    uint8_t *buf = nullptr;
    size_t bufsz;

    if ((curpos = ftell(inner(lexer)->file())) == -1) {
      return UINT32_MAX;
    }

    if (fseek(inner(lexer)->file(), *begoff, SEEK_SET) != 0) {
      return UINT32_MAX;
    }

    bufsz = span;

    if ((buf = (uint8_t *)malloc(bufsz + 1)) == nullptr) {
      fseek(inner(lexer)->file(), curpos, SEEK_SET);
      return UINT32_MAX;
    }

    if (fread(buf, 1, bufsz, inner(lexer)->file()) != bufsz) {
      free(buf);
      fseek(inner(lexer)->file(), curpos, SEEK_SET);
      return UINT32_MAX;
    }

    buf[bufsz] = '\0';
    fseek(inner(lexer)->file(), curpos, SEEK_SET);

    callback((const char *)buf, bufsz, userdata);

    free(buf);
    return span;
  } catch (...) {
    qcore_panic("qlex_spanx: failed to calculate span");
  }
}

///============================================================================///

static jmp_buf getc_jmpbuf;

char qlex_impl_t::getc() {
  /* Refill the buffer if necessary */
  if (m_bufpos == GETC_BUFFER_SIZE) [[unlikely]] {
    size_t read = fread(m_buf.data(), 1, GETC_BUFFER_SIZE, m_file);

    if (read == 0) [[unlikely]] {
      longjmp(getc_jmpbuf, 1);
    }

    memset(m_buf.data() + read, '\n', GETC_BUFFER_SIZE - read);
    m_bufpos = 0;
  }

  char c = m_buf[m_bufpos++];

  /* Update the row and column */
  if (c == '\n') {
    m_row++;
    m_col = 1;
  } else {
    m_col++;
  }

  m_offset++;

  return c;
}

qlex_tok_t qlex_impl_t::next() {
  if (!m_undo.empty()) {
    qlex_tok_t tok = m_undo.front();
    m_undo.pop();
    return tok;
  }

  if (m_tok_pos >= TOKEN_BUF_SIZE) [[unlikely]] {
    refill_buffer();
    m_tok_pos = 0;
  }

  return m_tokens[m_tok_pos++];
}

void qlex_impl_t::refill_buffer() {
  // C++ has some wierd UB if 'i' is initialized before the 'setjmp'
  static thread_local size_t i;

  if (setjmp(getc_jmpbuf) == 0) {
    i = 0;
    while (i < TOKEN_BUF_SIZE) {
      m_tokens[i] = do_automata();
      i = i + 1;
    }
  } else [[unlikely]] {
    m_tokens[i].ty = qEofF;

    reset_state();
  }

  /* Must clear to prevent leaks */
  if (num_cache.size() > 1000) {
    num_cache.clear();
  }

  if (can_cache.size() > 1000) {
    can_cache.clear();
  }
}

void qlex_impl_t::reset_state() { m_pushback.clear(); }
