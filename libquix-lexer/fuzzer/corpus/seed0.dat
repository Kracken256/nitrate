subsystem import pub sec pro type let var const static struct region group union opaque enum fstring impl fn noexcept foreign impure tsafe pure quasipure retropure crashpoint inline unsafe safe req if else for while do switch case default break continue ret retif retz retv form foreach __asm__ void undef null true false ?: => . + - * / % & | ^ ~ && || ^^ ! << >> >>> <<< ++ -- = += -= *= /= %= &= |= ^= &&= ||= ^^= <<= >>= >>>= <<<= < > <= >= == != as is in sizeof alignof typeof offsetof .. ... <=> bitcast_as reinterpret_as bitsizeof out as is in sizeof alignof typeof offsetof bitcast_as reinterpret_as bitsizeof out ( ) [ ] { } , : ;  try { while (true) { { /* If the Lexer over-consumed, we will return the saved character */ if (m_pushback.empty()) { eof_is_error = false; c = getc(); eof_is_error = true; } else { c = m_pushback.front(); m_pushback.pop_front(); } }  switch (state) { case LexState::Start: { if (c == ' ' || c == '\t' || c == '\n' || c == '\r') {   continue; } else if (std::isalpha(c) || c == '_') /* Identifier or keyword or operator */ {   buf += c, state = LexState::Identifier;   continue; } else if (c == '/') /* Comment or operator */ {   state = LexState::CommentStart;   continue; } else if (std::isdigit(c)) {   buf += c, state = LexState::Integer;   continue; } else if (c == '"' || c == '\'') {   buf += c, state = LexState::String;   continue; } else if (c == '@') {   state = LexState::MacroStart;   continue; } else /* Operator or punctor or invalid */ {   buf += c;   state = LexState::Other;   continue; } } case LexState::Identifier: { qlex::ident_buf_t ibuf; ibuf += buf[0];  { /* Read in what is hopefully an identifier */   int colon_state = 0;  while (std::isalnum(c) || c == '_' || c == ':') {   if (c != ':' && colon_state == 1) {   if (!ibuf.ends_with("::")) {     char tc = ibuf.back();     ibuf.pop_back();     m_pushback.push_back(tc);     break;   }   colon_state = 0;   } else if (c == ':') {   colon_state = 1;   }    ibuf += c;   c = getc();   } }  /* Check for f-string */ if (ibuf == "f" && c == '"') {   m_pushback.push_back(c);   return qlex_tok_t(qKeyW, off(), qKFString); }  /* We overshot; this must be a punctor ':' */ if (ibuf.size() > 0 && ibuf.back() == ':') {   char tc = ibuf.back();   ibuf.pop_back();   m_pushback.push_back(tc); } m_pushback.push_back(c);  /* Determine if it's a keyword or an identifier */ for (const auto &[left, right] : qlex::keywords) {   if (ibuf == left) {   return qlex_tok_t(qKeyW, off(), right);   } }  /* Check if it's an operator */ for (const auto &[left, right] : qlex::word_operators) {   if (ibuf == left) {   return qlex_tok_t(qOper, off(), right);   } }  /* Ensure it's a valid identifier */ if (!validate_identifier(ibuf)) {   goto error_0; }  /* Return the identifier */ return qlex_tok_t(qName, off(), m_holdings.retain(ibuf)); } case LexState::Integer: { qlex::num_buf_t nbuf;  nbuf += buf[0]; { /* Read in what is hopefully an integer */   while (true) {   if (!(std::isxdigit(c) || c == '_' || c == '-' || c == '.' || c == 'x' || c == 'b' ||     c == 'd' || c == 'o' || c == 'e' || c == '.')) {   break;   }    nbuf += c;   c = getc();   } }  { /* Handle lexical ambiguity */   std::vector<char> items;  bool cutting = true;   while (cutting) {   if (nbuf.empty()) {   break;   }    char last = nbuf.back();    switch (last) {   case '_':   case '.':   case '-':     items.push_back(last);     nbuf.pop_back();     break;   default:     cutting = false;     break;   }   }  for (auto it = items.rbegin(); it != items.rend(); ++it) {   m_pushback.push_back(*it);   }   m_pushback.push_back(c); }  /* Check if it's a floating point number */ NumType type; if ((type = check_number_literal_type(nbuf)) == NumType::Floating) {   return qlex_tok_t(qNumL, off(), m_holdings.retain(canonicalize_float(nbuf))); }  /* Check if it's a valid number */ if (type == NumType::Invalid) {   goto error_0; }  /* Canonicalize the number */ std::string norm; if (canonicalize_number(nbuf, norm, type)) {   return qlex_tok_t(qIntL, off(), m_holdings.retain(std::move(norm))); }  /* Invalid number */ got