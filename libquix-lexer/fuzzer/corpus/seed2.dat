}  bool found = false; while (true) { bool contains = false; for (const auto &[left, right] : qlex::operators) { if (left == buf) { contains = true; found = true; break; } }  if (contains) { buf += c; if (buf.size() > 4) { /* Handle infinite error case */ goto error_0; } c = getc(); } else { break; } }  if (!found) { goto error_0; }  m_pushback.push_back(buf.back()); m_pushback.push_back(c); return qlex_tok_t(qOper, off(), qlex::operators.left.at(buf.substr(0, buf.size() - 1))); } } } goto error_0; } catch (GetCControlFlow &) { /* This is just faster than checking for EOF everywhere */ if (eof_is_error) { goto error_0; } else { reset_state(); return qlex_tok_t::eof(off()); } } catch (std::exception &e) { /* This should never happen */ qcore_panicf("qlex_impl_t::do_automata: %s. The lexer has a bug.", e.what()); } catch (...) { /* This should never happen */ qcore_panic("qlex_impl_t::do_automata: unknown error. The lexe"  QType::Le: { if (lhs_val <= rhs_val) { *merged = Number::create("1"); } else { *merged = Number::create("0"); } break; } case QType::Ge: { if (lhs_val >= rhs_val) { *merged = Number::create("1"); } else { *merged = Number::create("0"); } break; } case QType::And: { *merged = Number::create(cpp_int(lhs_val && rhs_val).str()); break; } case QType::Or: { *merged = Number::create(cpp_int(lhs_val || rhs_val).str()); break; } case QType::Xor: { if ((lhs_val && rhs_val) || (!lhs_val && !rhs_val)) { *merged = Number::create("0"); } else { *merged = Number::create("1"); } break; } default: break; } } }  static void reduce_expr(Expr **expr) { if ((*expr)->is<Number>() || (*expr)->is<String>() || (*expr)->is<Char>()) { /* Base case: Skip if the expression is a literal */ return; }  #define BINARY_EXPR_REDUCE(_Name)        \ case QType::_Name: {         \ auto e = reinterpret_cast<_Name **>(expr);       \ reduce_expr(&(*e)->lhs);         \ reduce_expr(&(*e)->rhs);         \ try_to_merge((*e)->lhs, (*e)->rhs, expr);      \ break;           \ }  switch ((QType)(*expr)->ntype) { BINARY_EXPR_REDUCE(Add); BINARY_EXPR_REDUCE(Sub); BINARY_EXPR_REDUCE(Mul); BINARY_EXPR_REDUCE(Div); BINARY_EXPR_REDUCE(Mod); BINARY_EXPR_REDUCE(BitAnd); BINARY_EXPR_REDUCE(BitOr); BINARY_EXPR_REDUCE(BitXor); BINARY_EXPR_REDUCE(Shl); BINARY_EXPR_REDUCE(Shr); BINARY_EXPR_REDUCE(Rotl); BINARY_EXPR_REDUCE(Rotr); BINARY_EXPR_REDUCE(Eq); BINARY_EXPR_REDUCE(Ne); BINARY_EXPR_REDUCE(Lt); BINARY_EXPR_REDUCE(Gt); BINARY_EXPR_REDUCE(Le); BINARY_EXPR_REDUCE(Ge); BINARY_EXPR_REDUCE(And); BINARY_EXPR_REDUCE(Or); BINARY_EXPR_REDUCE(Xor); default: break; } }  bool libquixcc::optimizer::passes::ExprReduce(quixcc_cc_job_t &job,       std::unique_ptr<libquixcc::ir::q::QModule> &ir) { auto filter_expr = [](const ir::q::Value *val) -> IterOp { /* Test if the value is an expression */ if (dynamic_cast<const ir::q::Expr *>(val) == nullptr) { /* Skip non-expression values */ return IterOp::Skip; }  /* Continue iterating */ return IterOp::Do; };  auto transform = [](ir::q::Value **val) { auto expr = dynamic_cast<ir::q::Expr *>(*val); /* Skip if the value is not an expression */ if (expr == nullptr) { return; }  /* Reduce the expression */ reduce_expr(reinterpret_cast<ir::q::Expr **>(val)); };  ir->bft_iter(transform, filter_expr);  return true; } /* Calculate constant expression */ Number *nlhs = dynamic_cast<Number *>(lhs); Number *nrhs = dynamic_cast<Number *>(rhs);  if (nlhs->value.find(".") != std::string::npos || nrhs->value.find(".") != std::string::npos) {   cpp_dec_float_100 lhs_val, rhs_val;   lhs_val.assign(nlhs->value);   rhs_val.assign(nrhs->value); nclude <quixcc/IR/Q/Math.h> #include <quixcc/IR/Q/Variable.h> #include <quixcc/core/Logger.h> #include <quixcc/optimizer/Passes.h>  #include <boost/multiprecision/cpp_dec_float.hpp> #include <boost/multiprecision/cpp_int.hpp>  using namespace libquixcc; using namespace libquixcc::ir::q; using cpp_int = boost::multiprecision::cpp_int; using cpp_dec_float_100 = boost::multiprecision::cpp_dec_float_100;  static void try_to_merge(Expr *lhs, Expr *rhs, Expr **merged) { if (!((lhs->is<Number>() && rhs->is<Number>()) | 