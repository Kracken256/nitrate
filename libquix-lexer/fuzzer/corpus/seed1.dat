o error_0; } case LexState::CommentStart: { if (c == '/') { /* Single line comment */   state = LexState::CommentSingleLine;   continue; } else if (c == '*') { /* Multi-line comment */   state = LexState::CommentMultiLine;   continue; } else { /* Divide operator */   m_pushback.push_back(c);   return qlex_tok_t(qOper, off(), qOpSlash); } } case LexState::CommentSingleLine: { while (c != '\n') {   buf += c;   c = getc(); }  return qlex_tok_t(qNote, off(), m_holdings.retain(std::move(buf))); } case LexState::CommentMultiLine: { size_t level = 1;  while (true) {   if (c == '/') {   char tmp = getc();   if (tmp == '*') {   level++;   buf += "/*";   } else {   buf += c;   buf += tmp;   }    c = getc();   } else if (c == '*') {   char tmp = getc();   if (tmp == '/') {   level--;   if (level == 0) {     return qlex_tok_t(qNote, off(), m_holdings.retain(std::move(buf)));   } else {     buf += "*";     buf += tmp;   }   } else {   buf += c;   buf += tmp;   }   c = getc();   } else {   buf += c;   c = getc();   } }  continue; } case LexState::String: { if (c != buf[0]) {   /* Normal character */   if (c != '\\') {   buf += c;   continue;   }  /* String escape sequences */   c = getc();   switch (c) {   case 'n':   buf += '\n';   break;   case 't':   buf += '\t';   break;   case 'r':   buf += '\r';   break;   case '0':   buf += '\0';   break;   case '\\':   buf += '\\';   break;   case '\'':   buf += '\'';   break;   case '\"':   buf += '\"';   break;   case 'x': {   char hex[2] = {getc(), getc()};   if (!std::isxdigit(hex[0]) || !std::isxdigit(hex[1])) {     goto error_0;   }   buf += (qlex::hextable[(uint8_t)hex[0]] << 4) | qlex::hextable[(uint8_t)hex[1]];   break;   }   case 'u': {   char hex[4] = {getc(), getc(), getc(), getc()};   uint32_t codepoint = 0;   codepoint |= qlex::hextable[(uint8_t)hex[0]] << 12;   codepoint |= qlex::hextable[(uint8_t)hex[1]] << 8;   codepoint |= qlex::hextable[(uint8_t)hex[2]] << 4;   codepoint |= qlex::hextable[(uint8_t)hex[3]];   buf += codepoint;   break;   }   case 'o': {   char oct[4] = {getc(), getc(), getc(), 0};   // try {   buf += std::stoi(oct, nullptr, 8);   break;   // } catch (...) {   // goto error_0;   // }   }   default:   buf += c;   break;   }   continue; }  /* Character or string */ if (buf.front() == '\'' && buf.size() == 2) {   return qlex_tok_t(qChar, off(), m_holdings.retain(std::string(1, buf[1]))); } else {   return qlex_tok_t(qText, off(), m_holdings.retain(buf.substr(1, buf.size() - 1))); } } case LexState::MacroStart: { /*   * Macros start with '@' and can be either single-line or block   * macros. Block macros are enclosed in parentheses. Single-line   * macros end with a newline character or a special cases   */ if (c == '(') {   state = LexState::BlockMacro, state_parens = 1;   continue; } else {   state = LexState::SingleLineMacro, state_parens = 0;   buf += c;   continue; } break; } case LexState::SingleLineMacro: { /* Format:   ... @macro_name(arg1, arg2, arg3, ...) ... */  while (true) {   if (c == '(') {   state_parens++;   } else if (c == ')') {   state_parens--;    if (state_parens == 0) {   buf += ')';   return qlex_tok_t(qMacr, off(), m_holdings.retain(std::move(buf)));   }   }  if (c == '\n') {   return qlex_tok_t(qMacr, off(), m_holdings.retain(std::move(buf)));   }  buf += c;  c = getc(); } continue; } case LexState::BlockMacro: { while (true) {   if (c == '(') {   state_parens++;   } else if (c == ')') {   state_parens--;   }  if (state_parens == 0) {   return qlex_tok_t(qMacB, off(), m_holdings.retain(std::move(buf)));   }  buf += c;  c = getc(); } continue; } case LexState::Other: { /* Check if it's a punctor */ if (buf.size() == 1) {   for (const auto &[left, right] : qlex::punctuation) {   if (left == buf) {   m_pushback.push_back(c);   return qlex_tok_t(qPunc, off(), right);   }   } }  /* Special case for a comment */ if ((buf[0] == '~' && c == '>')) {   buf.clear();   state = LexState::CommentSingleLine;   continue; }  /* Special case for a comment */ if (buf[0] == '#') {   buf.clear();   buf += c;   state = LexState::CommentSingleLine;   continue; 