
qlex_tok_t qlex_impl_t::do_automata() noexcept {
enum class LexState {
Start,
Identifier,
String,
Integer,
CommentStart,
CommentSingleLine,
CommentMultiLine,
MacroStart,
SingleLineMacro,
BlockMacro,
Other,
};

std::string buf;

LexState state = LexState::Start;
uint32_t state_parens = 0;
char c;
bool eof_is_error = true;

try {
while (true) {
{ /* If the Lexer over-consumed, we will return the saved character */
if (m_pushback.empty()) {
  eof_is_error = false;
  c = getc();
  eof_is_error = true;
} else {
  c = m_pushback.front();
  m_pushback.pop_front();
}
}

switch (state) {
case LexState::Start: {
  if (c == ' ' || c == '\t' || c == '\n' || c == '\r') {
    continue;
  } else if (std::isalpha(c) || c == '_') /* Identifier or keyword or operator */
  {
    buf += c, state = LexState::Identifier;
    continue;
  } else if (c == '/') /* Comment or operator */
  {
    state = LexState::CommentStart;
    continue;
  } else if (std::isdigit(c)) {
    buf += c, state = LexState::Integer;
    continue;
  } else if (c == '"' || c == '\'') {
    buf += c, state = LexState::String;
    continue;
  } else if (c == '@') {
    state = LexState::MacroStart;
    continue;
  } else /* Operator or punctor or invalid */
  {
    buf += c;
    state = LexState::Other;
    continue;
  }
}
case LexState::Identifier: {
  qlex::ident_buf_t ibuf;
  ibuf += buf[0];

  { /* Read in what is hopefully an identifier */
    int colon_state = 0;

    while (std::isalnum(c) || c == '_' || c == ':') {
      if (c != ':' && colon_state == 1) {
        if (!ibuf.ends_with("::")) {
          char tc = ibuf.back();
          ibuf.pop_back();
          m_pushback.push_back(tc);
          break;
        }
        colon_state = 0;
      } else if (c == ':') {
        colon_state = 1;
      }

      ibuf += c;
      c = getc();
    }
  }

  /* Check for f-string */
  if (ibuf == "f" && c == '"') {
    m_pushback.push_back(c);
    return qlex_tok_t(qKeyW, off(), qKFString);
  }

  /* We overshot; this must be a punctor ':' */
  if (ibuf.size() > 0 && ibuf.back() == ':') {
    char tc = ibuf.back();
    ibuf.pop_back();
    m_pushback.push_back(tc);
  }
  m_pushback.push_back(c);

  /* Determine if it's a keyword or an identifier */
  for (const auto &[left, right] : qlex::keywords) {
    if (ibuf == left) {
      return qlex_tok_t(qKeyW, off(), right);
    }
  }

  /* Check if it's an operator */
  for (const auto &[left, right] : qlex::word_operators) {
    if (ibuf == left) {
      return qlex_tok_t(qOper, off(), right);
    }
  }

  /* Ensure it's a valid identifier */
  if (!validate_identifier(ibuf)) {
    goto error_0;
  }

  /* Return the identifier */
  return qlex_tok_t(qName, off(), m_holdings.retain(ibuf));
}
case LexState::Integer: {
  qlex::num_buf_t nbuf;

  nbuf += buf[0];
  { /* Read in what is hopefully an integer */
    while (true) {
      if (!(std::isxdigit(c) || c == '_' || c == '-' || c == '.' || c == 'x' || c == 'b' ||
            c == 'd' || c == 'o' || c == 'e' || c == '.')) {
        break;
      }

      nbuf += c;
      c = getc();
    }
  }

  { /* Handle lexical ambiguity */
    std::vector<char> items;

    bool cutting = true;
    while (cutting) {
      if (nbuf.empty()) {
        break;
      }

      char last = nbuf.back();

      switch (last) {
        case '_':
        case '.':
        case '-':
          items.push_back(last);
          nbuf.pop_back();
          break;
        default:
          cutting = false;
          break;
      }
    }

    for (auto it = items.rbegin(); it != items.rend(); ++it) {
      m_pushback.push_back(*it);
    }
    m_pushback.push_back(c);
  }

  /* Check if it's a floating point number */
  NumType type;
  if ((type = check_number_literal_type(nbuf)) == NumType::Floating) {
    return qlex_tok_t(qNumL, off(), m_holdings.retain(canonicalize_float(nbuf)));
  }

  /* Check if it's a valid number */
  if (type == NumType::Invalid) {
    goto error_0;
  }

  /* Canonicalize the number */
  std::string norm;
  if (canonicalize_number(nbuf, norm, type)) {
    return qlex_tok_t(qIntL, off(), m_holdings.retain(std::move(norm)));
  }

  /* Invalid number */
  goto error_0;
}
case LexState::CommentStart: {
  if (c == '/') { /* Single line comment */
    state = LexState::CommentSingleLine;
    continue;
  } else if (c == '*') { /* Multi-line comment */
    state = LexState::CommentMultiLine;
    continue;
  } else { /* Divide operator */
    m_pushback.push_back(c);
    return qlex_tok_t(qOper, off(), qOpSlash);
  }
}
case LexState::CommentSingleLine: {
  while (c != '\n') {
    buf += c;
    c = getc();
  }

  return qlex_tok_t(qNote, off(), m_holdings.retain(std::move(buf)));
}
case LexState::CommentMultiLine: {
  size_t level = 1;

  while (true) {
    if (c == '/') {
      char tmp = getc();
      if (tmp == '*') {
        level++;
        buf += "/*";
      } else {
        buf += c;
        buf += tmp;
      }

      c = getc();
    } else if (c == '*') {
      char tmp = getc();
      if (tmp == '/') {
        level--;
        if (level == 0) {
          return qlex_tok_t(qNote, off(), m_holdings.retain(std::move(buf)));
        } else {
          buf += "*";
          buf += tmp;
        }
      } else {
        buf += c;
        buf += tmp;
      }
      c = getc();
    } else {
      buf += c;
      c = getc();
    }
  }

  continue;
}
case LexState::String: {
  if (c != buf[0]) {
    /* Normal character */
    if (c != '\\') {
      buf += c;
      continue;
    }

    /* String escape sequences */
    c = getc();
    switch (c) {
      case 'n':
        buf += '\n';
        break;
      case 't':
        buf += '\t';
        break;
      case 'r':
        buf += '\r';
        break;
      case '0':
        buf += '\0';
        break;
      case '\\':
        buf += '\\';
        break;
      case '\'':
        buf += '\'';
        break;
      case '\"':
        buf += '\"';
        break;
      case 'x': {
        char hex[2] = {getc(), getc()};
        if (!std::isxdigit(hex[0]) || !std::isxdigit(hex[1])) {
          goto error_0;
        }
        buf += (qlex::hextable[(uint8_t)hex[0]] << 4) | qlex::hextable[(uint8_t)hex[1]];
        break;
      }
      case 'u': {
        char hex[4] = {getc(), getc(), getc(), getc()};
        uint32_t codepoint = 0;
        codepoint |= qlex::hextable[(uint8_t)hex[0]] << 12;
        codepoint |= qlex::hextable[(uint8_t)hex[1]] << 8;
        codepoint |= qlex::hextable[(uint8_t)hex[2]] << 4;
        codepoint |= qlex::hextable[(uint8_t)hex[3]];
        buf += codepoint;
        break;
      }
      case 'o': {
        char oct[4] = {getc(), getc(), getc(), 0};
        // try {
        buf += std::stoi(oct, nullptr, 8);
        break;
        // } catch (...) {
        //   goto error_0;
        // }
      }
      default:
        buf += c;
        break;
    }
    continue;
  }

  /* Character or string */
  if (buf.front() == '\'' && buf.size() == 2) {
    return qlex_tok_t(qChar, off(), m_holdings.retain(std::string(1, buf[1])));
  } else {
    return qlex_tok_t(qText, off(), m_holdings.retain(buf.substr(1, buf.size() - 1)));
  }
}
case LexState::MacroStart: {
  /*
    * Macros start with '@' and can be either single-line or block
    * macros. Block macros are enclosed in parentheses. Single-line
    * macros end with a newline character or a special cases
    */
  if (c == '(') {
    state = LexState::BlockMacro, state_parens = 1;
    continue;
  } else {
    state = LexState::SingleLineMacro, state_parens = 0;
    buf += c;
    continue;
  }
  break;
}
case LexState::SingleLineMacro: {
  /*
  Format:
      ... @macro_name(arg1, arg2, arg3, ...) ...
  */

  while (true) {
    if (c == '(') {
      state_parens++;
    } else if (c == ')') {
      state_parens--;

      if (state_parens == 0) {
        buf += ')';
        return qlex_tok_t(qMacr, off(), m_holdings.retain(std::move(buf)));
      }
    }

    if (c == '\n') {
      return qlex_tok_t(qMacr, off(), m_holdings.retain(std::move(buf)));
    }

    buf += c;

    c = getc();
  }
  continue;
}
case LexState::BlockMacro: {
  while (true) {
    if (c == '(') {
      state_parens++;
    } else if (c == ')') {
      state_parens--;
    }

    if (state_parens == 0) {
      return qlex_tok_t(qMacB, off(), m_holdings.retain(std::move(buf)));
    }

    buf += c;

    c = getc();
  }
  continue;
}
case LexState::Other: {
  /* Check if it's a punctor */
  if (buf.size() == 1) {
    for (const auto &[left, right] : qlex::punctuation) {
      if (left == buf) {
        m_pushback.push_back(c);
        return qlex_tok_t(qPunc, off(), right);
      }
    }
  }

  /* Special case for a comment */
  if ((buf[0] == '~' && c == '>')) {
    buf.clear();
    state = LexState::CommentSingleLine;
    continue;
  }

  /* Special case for a comment */
  if (buf[0] == '#') {
    buf.clear();
    buf += c;
    state = LexState::CommentSingleLine;
    continue;
  }

  bool found = false;
  while (true) {
    bool contains = false;
    for (const auto &[left, right] : qlex::operators) {
      if (left == buf) {
        contains = true;
        found = true;
        break;
      }
    }

    if (contains) {
      buf += c;
      if (buf.size() > 4) { /* Handle infinite error case */
        goto error_0;
      }
      c = getc();
    } else {
      break;
    }
  }

  if (!found) {
    goto error_0;
  }

  m_pushback.push_back(buf.back());
  m_pushback.push_back(c);
  return qlex_tok_t(qOper, off(), qlex::operators.left.at(buf.substr(0, buf.size() - 1)));
}
}
}
goto error_0;
} catch (GetCControlFlow &) { /* This is just faster than checking for EOF everywhere */
if (eof_is_error) {
goto error_0;
} else {
reset_state();
return qlex_tok_t::eof(off());
}
} catch (std::exception &e) { /* This should never happen */
qcore_panicf("qlex_impl_t::do_automata: %s. The lexer has a bug.", e.what());
} catch (...) { /* This should never happen */
qcore_panic("qlex_impl_t::do_automata: unknown error. The lexe"
