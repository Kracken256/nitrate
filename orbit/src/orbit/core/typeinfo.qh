///////////////////////////////////////////////////////////////////////////////
///                                                                         ///
///    ░▒▓██████▓▒░  ░▒▓███████▓▒░  ░▒▓███████▓▒░  ░▒▓█▓▒░ ░▒▓████████▓▒░   ///
///   ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░    ░▒▓█▓▒░       ///
///   ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░    ░▒▓█▓▒░       ///
///   ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓███████▓▒░  ░▒▓███████▓▒░  ░▒▓█▓▒░    ░▒▓█▓▒░       ///
///   ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░    ░▒▓█▓▒░       ///
///   ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░    ░▒▓█▓▒░       ///
///    ░▒▓██████▓▒░  ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓███████▓▒░  ░▒▓█▓▒░    ░▒▓█▓▒░       ///
///                                                                         ///
///     * ORBIT STANDARD LIBRARY - The official stdlib for QUIX.            ///
///     * Copyright (c) 2024, Wesley C. Jones.                              ///
///     * License terms may be found in the LICENSE file.                   ///
///                                                                         ///
///////////////////////////////////////////////////////////////////////////////

@use "v1.0"
@language "en"
@copyright "Wesley Jones; MIT license"

@import orbit::core::trait;

subsystem orbit::core {
    group TypeInfo {
        mangled: string,     ~> The mangled name of the thing.
        demangled: string,   ~> The demangled name of the thing.
        hash: [u8; 16],      ~> The cryptographic hash of the thing.
        tag: u64,            ~> A tag that is guaranteed to be for the compilation.

        defcol: u64,         ~> The column number that the thing was defined at.
        defline: u64,        ~> The line number that the thing was defined at.
        deffile: string,     ~> The file that the thing was defined in.

        size: u64,           ~> The size of the thing in bytes or 0 if not applicable.

        is_polymorphic: bool,
        is_abstract: bool,   
        is_immutable: bool,   
        is_const: bool,   
        is_signed: bool,    
        is_unsigned: bool,   
        is_atomic: bool,  
        is_volatile: bool,
    } : iter{*}, mini{tag, demangled};

    fn __polymorphic_type_lookup(ptr: unsafe_ptr): TypeInfo {
        let vtab_idx = *(ptr as *u32);

        @(if debug {
            if vtab_idx >= @__QUIX_TYPE_TABEL_GLOBAL__.len() {
                panic("Invalid vtable index.");
            }
        })

        ret @__QUIX_TYPE_TABEL_GLOBAL__[vtab_idx];
    }

    /// @brief Check if a thing is polymorphic.
    /// @param value The thing (struct, identifier, etc.) to
    /// check if it is polymorphic.
    /// @return True if the thing is polymorphic, false otherwise.
    /// @note This function is an intrinsic.
    @(fn is_polymorphic(value: string): bool => 
            @__QUIX_META_TABLE__["typeinfo"][this][value].is_polymorphic;);

    @(fn is_same(a: string, b: string): bool => 
            @__QUIX_META_TABLE__["typeinfo"][this][a].hash == 
            @__QUIX_META_TABLE__["typeinfo"][this][b].hash;);

    /// @brief Get the type information for a thing.
    /// @param value The thing (struct, enum, identifier, function, etc.) to
    /// get the type information for.
    /// @return The type information for the thing.
    /// @note This function is an intrinsic.
    /// @note The hash is not guaranteed to be unique accross different 
    /// compilations or different compilers.
    @(fn typeof(value: string): TypeInfo {
        if @__QUIX_META_TABLE__["typeinfo"][this].has(value) {
            if @is_same(value, "any") {
                ret TypeInfo {
                    mangled: "any",
                    demangled: "any",
                    hash: [0; 16],
                    tag: 0,
                    defcol: 0,
                    defline: 0,
                    deffile: "",
                    size: 0,
                    is_polymorphic: false,
                    is_abstract: false,
                    is_immutable: false,
                    is_const: false,
                    is_signed: false,
                    is_unsigned: false,
                    is_atomic: false,
                    is_volatile: false,
                };
            }

            retif !@is_polymorphic(value) @__QUIX_META_TABLE__["typeinfo"][this][value];
        }

        ret __polymorphic_type_lookup(destr(value) as unsafe_ptr);
    });

    /// @brief Get the type name of a thing.
    /// @param value The thing (struct, enum, identifier, function, etc.) to
    /// get the type name for.
    /// @return The type name of the thing.
    /// @note This function is an intrinsic.
    @(fn typename(value: string): string => typeof(value).demangled;);
}