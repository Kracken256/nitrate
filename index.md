---

layout: home
---

# Welcome to the QUIX website!

**Everything on this site is a work in progress. And the language is in rapid development.**

What is QUIX?
---

QUIX is a high-level, statically typed, memory-safe, garbage-collected, high-performance, object-oriented, general-purpose systems programming language designed to be safe, expressive, and performant. QUIX supports runtime reflection, low-level memory access, namespaces, mandatory explicit typing, packed data types, classes, operator overloading, coroutines, default initializers, arbitrary precision math, destructors, automatic memory management, and metaprogramming.

QUIX is especially well-suited for library development, game development, and systems programming. QUIX is designed to be a modern, safe, and expressive alternative to C++ and Rust.

Why QUIX?
---

1. **Safety**: QUIX is memory-safe and type-safe.
1. **Performance**: QUIX is fast. QUIX is designed to be as fast as C++. Memory is managed automatically using reference counting.
1. **Expressiveness**: QUIX uses human readable keywords. QUIX avoids strange symbols and cryptic syntax. QUIX is designed to be easy to read.
1. **Prety**: C++ is beautiful, but it is not safe. Rust is hideous, but it is safe. Go is nice, but it is limited. QUIX is designed to be safe, pretty, and feature-rich.
1. **Compatibile**: QUIX links to C, C++, and DLang objects out of the box. No need for annoying and ugly bindings or wrappers. There is no overhead when calling C, C++, or DLang functions.
1. **Reusability**: Because QUIX plays well with C++, the QUIX standard library is vast. The library contains a lot of useful tools such as Math, File I/O, Networking, Compression, Cryptography (OpenSSL wrapper), and more.
1. **Small Binaries**: QUIX produces small packed binaries. The standard library is modular and unrelated code is not linked into the final binary. If you don't call it, it's not there. Binaries start at ~8KB.

[Read the Documentation](/docs/)
